{
  "version": 3,
  "sources": ["../src/effects.ts"],
  "sourcesContent": ["import type { RecordData } from \"@gadgetinc/api-client-core\";\nimport { ChangeTracking, GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport {\n  InternalError,\n  InvalidActionInputError,\n  InvalidStateTransitionError,\n  MisconfiguredActionError,\n  NoSessionForAuthenticationError,\n  PermissionDeniedError,\n  UserNotSetOnSessionError,\n} from \"./errors\";\nimport { Globals, actionContextLocalStorage } from \"./globals\";\nimport { modelListIndex, modelsMap } from \"./metadata\";\nimport { AppTenancyKey } from \"./tenancy\";\nimport type { AnyParams, ModelMetadata, NotYetTyped } from \"./types\";\nimport { assert } from \"./utils\";\n\nfunction getBelongsToRelationParams(model: ModelMetadata, params: Record<string, any>) {\n  const belongsToParams: any = {};\n\n  for (const field of Object.values(model.fields) as any[]) {\n    if (field.fieldType != \"BelongsTo\") continue;\n    const modelParams = typeof params[model.apiIdentifier] === \"object\" ? params[model.apiIdentifier] : undefined;\n    const belongsToParam =\n      modelParams && typeof modelParams[field.apiIdentifier] === \"object\" ? modelParams[field.apiIdentifier] : undefined;\n    const belongsToId = belongsToParam?.[LINK_PARAM] !== undefined ? belongsToParam[LINK_PARAM] : belongsToParam?.id;\n    if (belongsToId !== undefined) {\n      belongsToParams[`${field.apiIdentifier}Id`] = belongsToId;\n    }\n  }\n\n  return belongsToParams;\n}\n\nexport function createGadgetRecord<Shape>(apiIdentifier: string, data: Shape): GadgetRecord<Shape & { __typename: string }> {\n  const model = getModelByApiIdentifier(apiIdentifier);\n  return new GadgetRecord({\n    ...data,\n    __typename: model.graphqlTypeName,\n  });\n}\n\n/**\n * Set incoming parameters onto a `record` object.\n *\n * @param params - Parameters for setting, usually from an action context or a  to set on the record\n * @param record - Record to apply parameters to\n */\nexport function applyParams(params: AnyParams, record: GadgetRecord<any>) {\n  const model = getModelByTypename(record.__typename);\n\n  // override the record with any new params, including relationId params from any _link params on belongs to relationships\n  // Change the code snippet in `ApplyParamsDetailsPanel.tsx` when the code below updates\n  Object.assign(record, params[model.apiIdentifier], getBelongsToRelationParams(model, params));\n}\n\n/**\n * Validates the given record, then creates or updates the record in the database.\n *\n * If any validation errors are encountered, they'll be thrown as a GadgetValidationError.\n *\n * Uses the Internal API for your application to persist data.\n *\n * The record param must have a `__typename` parameter.\n *\n * @param record - Record to save to the database\n */\nexport async function save(record: GadgetRecord<any>) {\n  const context = maybeGetActionContextFromLocalStorage();\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n  const model = getModelByTypename(record.__typename);\n\n  await (await Globals.modelValidator(model.key)).validate({ api, logger: Globals.logger }, record);\n\n  if (!api.internal[model.apiIdentifier]) {\n    throw new InternalError(\n      `Gadget API client doesn't have an internal model manager for ${model.apiIdentifier} to run a Save Record function -- has it finished regenerating or was it recently removed?`\n    );\n  }\n\n  let result: GadgetRecord<any>;\n\n  if (\"createdAt\" in record && record.createdAt) {\n    result = await api.internal[model.apiIdentifier].update(record.id, {\n      [model.apiIdentifier]: changedAttributes(model, record),\n    });\n  } else {\n    result = await api.internal[model.apiIdentifier].create({\n      [model.apiIdentifier]: writableAttributes(model, record),\n    });\n  }\n\n  Object.assign(record, { ...result });\n  record.flushChanges(ChangeTracking.SinceLastPersisted);\n}\n\n/**\n * Deletes the given record from your database.\n *\n * @param record - Record to delete from the database\n */\nexport async function deleteRecord(record: GadgetRecord<any>) {\n  const context = maybeGetActionContextFromLocalStorage();\n\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n  const scope = context ? context.scope : {};\n  const model = getModelByTypename(record.__typename);\n\n  const id = assert(record.id, `record.id not set on record in scope, has the record been persisted?`);\n\n  if (!api.internal[model.apiIdentifier]) {\n    throw new InternalError(\n      `Gadget API client doesn't have an internal model manager for ${model.apiIdentifier} to run a Delete Record effect -- has it finished regenerating or was it recently removed?`\n    );\n  }\n\n  await api.internal[model.apiIdentifier].delete(id);\n  scope.recordDeleted = true;\n}\n\nexport const ShopifyShopState = {\n  Installed: { created: \"installed\" },\n  Uninstalled: { created: \"uninstalled\" },\n};\n\nexport const ShopifySyncState = {\n  Created: \"created\",\n  Running: \"running\",\n  Completed: \"completed\",\n  Errored: \"errored\",\n};\n\nexport const ShopifyBulkOperationState = {\n  Created: \"created\",\n  Completed: \"completed\",\n  Canceled: \"canceled\",\n  Failed: \"failed\",\n  Expired: \"expired\",\n};\n\nexport const ShopifySellingPlanGroupProductVariantState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\nexport const ShopifySellingPlanGroupProductState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\nexport function transitionState(\n  record: GadgetRecord<any>,\n  transition: {\n    from?: string | Record<string, string>;\n    to: string | Record<string, string>;\n  }\n) {\n  const stringRecordState = typeof record.state === \"string\" ? record.state : JSON.stringify(record.state);\n  const stringTransitionFrom = typeof transition.from === \"string\" ? transition.from : JSON.stringify(transition.from);\n\n  if (transition.from && stringRecordState !== stringTransitionFrom) {\n    throw new InvalidStateTransitionError(undefined, {\n      state: record.state,\n      expectedFrom: transition.from,\n    });\n  }\n\n  record.state = transition.to;\n}\n\nexport async function shopifySync(params: AnyParams, record: GadgetRecord<any>) {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: { syncSince?: Date; id: bigint; shopId: string; models: any; force: boolean } = assert(\n    record,\n    \"cannot start a shop sync from this action\"\n  );\n\n  const shopId = assert(syncRecord.shopId, \"a shop is required to start a sync\");\n\n  // verify that models is an array of strings if defined\n\n  if (!syncRecord.models || (Array.isArray(syncRecord.models) && syncRecord.models.every((m) => typeof m == \"string\"))) {\n    try {\n      await effectAPIs.sync(\n        syncRecord.id.toString(),\n        shopId,\n        syncRecord.syncSince,\n        syncRecord.models,\n        syncRecord.force,\n        params.startReason\n      );\n    } catch (error) {\n      Globals.logger.error({ error, connectionSyncId: syncRecord.id }, \"an error occurred starting shop sync\");\n      throw error;\n    }\n  } else {\n    throw new InvalidActionInputError(\"Models must be an array of api identifiers\");\n  }\n}\n\nexport async function abortSync(params: AnyParams, record: GadgetRecord<any>) {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: { id: bigint } = assert(record, \"a record is required to abort a shop sync\");\n\n  const syncId = assert(syncRecord.id, \"a sync id is required to start a sync\");\n\n  if (!params.errorMessage) {\n    record.errorMessage = \"Sync aborted\";\n  }\n\n  Globals.logger.info({ userVisible: true, connectionSyncId: syncId }, \"aborting sync\");\n\n  try {\n    await effectAPIs.abortSync(syncId.toString());\n  } catch (error) {\n    Globals.logger.error({ error, connectionSyncId: syncId }, \"an error occurred aborting sync\");\n    throw error;\n  }\n}\n\n/**\n * Enforce that the given record is only accessible by the current shop. For multi-tenant Shopify applications, this is key for enforcing data can only be accessed by the shop that owns it.\n *\n * For existing records, this function verifies the record object has the same `shopId` as the shop in the current session, and throws if not\n * For new records, this function sets the record's `shopId` to the current session's `shopId`.\n *\n * The `shopBelongsToField` option is a required parameter if the model has more than one related shop field to specify which field to use.\n *\n * @param params - Incoming parameters, validated against the current `shopId`\n * @param record - Record to validate or set the `shopId` on\n * @param options - Options for the function\n */\nexport async function preventCrossShopDataAccess(params: AnyParams, record: GadgetRecord<any>, options?: { shopBelongsToField: string }) {\n  const context = getActionContextFromLocalStorage();\n  if (context.type != \"effect\") {\n    throw new Error(\"Can't prevent cross shop data access outside of an action effect\");\n  }\n  if (!params) {\n    throw new Error(\n      \"The `params` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  if (!record) {\n    throw new Error(\n      \"The `record` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  const model = context.model;\n  const appTenancy = context[AppTenancyKey];\n  const shopBelongsToField = options?.shopBelongsToField;\n\n  // if there's no tenancy let's continue\n  if (appTenancy?.shopify?.shopId === undefined) {\n    return;\n  }\n\n  // if this effect is not run in the context of a model then it does not apply\n  if (!model) {\n    return;\n  }\n\n  const shopId = String(appTenancy.shopify.shopId);\n\n  // If this effect is being added to the Shopify Shop model, simply compare the record's ID\n  if (model.key == ShopifyShopKey) {\n    if (record && String(record.id) !== shopId) {\n      throw new PermissionDeniedError();\n    }\n    return;\n  }\n\n  const fieldsIsBelongsToShopifyShop = Object.values(model.fields).filter(\n    (f) => f.fieldType === (FieldType.BelongsTo as string) && f.configuration.relatedModelKey === ShopifyShopKey\n  );\n\n  if (fieldsIsBelongsToShopifyShop.length === 0) {\n    throw new MisconfiguredActionError(\"This model is missing a related shop field.\");\n  }\n\n  if (fieldsIsBelongsToShopifyShop.length > 1 && !shopBelongsToField) {\n    throw new MisconfiguredActionError(\n      \"This function is missing a related shop field option. `shopBelongsToField` is a required option parameter if the model has more than one related shop field.\"\n    );\n  }\n\n  let relatedField = fieldsIsBelongsToShopifyShop[0];\n\n  if (shopBelongsToField) {\n    const selectedField = Object.values(model.fields).find((f) => f.apiIdentifier === shopBelongsToField);\n    if (!selectedField) {\n      throw new MisconfiguredActionError(\"The selected shop relation field does not exist.\");\n    }\n\n    if (selectedField.fieldType !== (FieldType.BelongsTo as string) || selectedField.configuration.relatedModelKey !== ShopifyShopKey) {\n      throw new MisconfiguredActionError(\n        \"The selected shop relation field should be a `Belongs To` relationship to the `Shopify Shop` model.\"\n      );\n    } else {\n      relatedField = selectedField;\n    }\n  }\n\n  const input = params[model.apiIdentifier];\n\n  // if we're trying to set the params to a shop other than the tenant we should reject\n  if (Globals.platformModules.lodash().isObjectLike(input)) {\n    const objectInput = input as Record<string, any>;\n    if (objectInput[relatedField.apiIdentifier]) {\n      if (String(objectInput[relatedField.apiIdentifier][LINK_PARAM]) !== shopId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      objectInput[relatedField.apiIdentifier] = {\n        [LINK_PARAM]: shopId,\n      };\n    }\n  } else {\n    params[model.apiIdentifier] = {\n      [relatedField.apiIdentifier]: {\n        [LINK_PARAM]: shopId,\n      },\n    };\n  }\n\n  if (record) {\n    const value = record.getField(relatedField.apiIdentifier);\n\n    // if the record doesn't have a shop set then anyone can update it\n    if (value) {\n      const recordShopId = typeof value === \"object\" ? value[LINK_PARAM] : value;\n      if (String(recordShopId) !== shopId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      // we have to re-apply the params to the record to ensure that this effect still works correctly if it occurs after \"apply params\"\n      record.setField(relatedField.apiIdentifier, {\n        [LINK_PARAM]: shopId,\n      });\n    }\n  }\n}\n\nexport async function finishBulkOperation(record: GadgetRecord<any>) {\n  if (!record?.id) {\n    Globals.logger.warn(`Expected bulk operation record to be present for action`);\n    return;\n  }\n\n  const context = getActionContextFromLocalStorage();\n  const shopifyAPI = await (context.connections as Record<string, any>).shopify.forShopId(record.shopId);\n  if (!shopifyAPI) {\n    Globals.logger.error(`Could not instantiate Shopify client for shop ID ${record.shopId}`);\n    return;\n  }\n  const bulkOperation = (\n    await shopifyAPI.graphql(`query {\n        node(id: \"${ShopifyBulkOperationGIDForId(record.id)}\") {\n          ... on BulkOperation {\n            id\n            status\n            errorCode\n            createdAt\n            completedAt\n            objectCount\n            fileSize\n            url\n            type\n            partialDataUrl\n            rootObjectCount\n          }\n        }\n      }`)\n  ).node;\n\n  // normalize the mixed upper/lowercase (GraphQL/REST) to lowercase\n  const { status, errorCode, type } = bulkOperation;\n  Object.assign(record, {\n    ...bulkOperation,\n    status: status?.toLowerCase(),\n    errorCode: errorCode?.toLowerCase(),\n    type: type?.toLowerCase(),\n    id: record.id,\n  });\n}\n\nexport async function globalShopifySync(params: {\n  apiKeys: string[];\n  syncSince: string;\n  models: string[];\n  force: boolean;\n  startReason: string;\n}) {\n  const context = maybeGetActionContextFromLocalStorage();\n  const effectAPIs = assert(\n    context ? context.effectAPIs : getCurrentContext().effectAPIs,\n    \"effect apis is missing from the current context\"\n  );\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n\n  const { apiKeys, syncSince, models, force, startReason } = params;\n\n  const { shopModelIdentifier, installedViaKeyFieldIdentifier, runShopSyncIdentifier, accessTokenIdentifier, forceFieldIdentifier } =\n    await effectAPIs.getSyncIdentifiers();\n\n  const pageSize = 250;\n  let pageInfo: { first?: number; endCursor?: string; hasNextPage: boolean } = { first: pageSize, hasNextPage: true };\n  const results: { id: string; domain: string; state: Record<string, any>; [key: string]: any }[] = [];\n\n  if (apiKeys && apiKeys.length > 0) {\n    try {\n      while (pageInfo.hasNextPage) {\n        const records = await api.internal[shopModelIdentifier].findMany({\n          filter: {\n            [installedViaKeyFieldIdentifier]: {\n              in: apiKeys,\n            },\n            state: {\n              inState: \"created.installed\",\n            },\n            planName: {\n              notIn: [\"frozen\", \"fraudulent\", \"cancelled\"],\n            },\n          },\n          first: pageInfo.first,\n          after: pageInfo.endCursor,\n        });\n        results.push(...records);\n        pageInfo = records.pagination.pageInfo;\n      }\n    } catch (error) {\n      Globals.logger.info({ userVisible: true, error, apiKeys }, \"could not get shops for all API keys\");\n      throw error;\n    }\n\n    for (const result of results) {\n      // skip the sync if there is no accessToken set or if the state is uninstalled\n      if (Globals.platformModules.lodash().isEmpty(result[accessTokenIdentifier]) || result.state?.created == \"uninstalled\") {\n        Globals.logger.info({ shopId: result.id }, \"skipping sync for shop without access token or is uninstalled\");\n        continue;\n      }\n\n      try {\n        const response = await api.mutate(\n          `\n            mutation runSync($shopId: GadgetID!, $domain: String!, $syncSince: DateTime, $models: JSON${\n              forceFieldIdentifier ? \", $force: Boolean\" : \"\"\n            }, $startReason: String) {\n              ${runShopSyncIdentifier}(shopifySync:{\n                domain:$domain\n                syncSince:$syncSince\n                models:$models\n                ${forceFieldIdentifier ? `${forceFieldIdentifier}:$force` : \"\"}\n                shop:{\n                  _link:$shopId\n                }\n              }, startReason: $startReason) {\n                success\n                errors {\n                  message\n                }\n              }\n            }\n          `,\n          {\n            shopId: result.id,\n            domain: result.domain,\n            syncSince,\n            models,\n            ...(forceFieldIdentifier ? { force } : undefined),\n            startReason,\n          }\n        );\n\n        // we might have some errors such as the desired models not being enabled for the connection\n        if (response[runShopSyncIdentifier] && !response[runShopSyncIdentifier].success) {\n          Globals.logger.warn(\n            { userVisible: true, shop: result, error: response[runShopSyncIdentifier].errors },\n            \"couldn't start sync for shop\"\n          );\n        }\n      } catch (error) {\n        // log that the sync could not be started for the shop but continue\n        Globals.logger.warn({ userVisible: true, error, shop: result }, \"couldn't start sync for shop\");\n      }\n    }\n  } else {\n    throw new InvalidActionInputError(\"missing at least 1 api key\");\n  }\n}\n\nexport function legacySetUser() {\n  const context = getActionContextFromLocalStorage();\n\n  if (!context.scope.authenticatedUser) {\n    throw new UserNotSetOnSessionError(\n      \"The authenticated user could not be saved to the session when logging in. Make sure the user has a role assigned to them.\"\n    );\n  }\n  if (!context.session) {\n    throw new NoSessionForAuthenticationError(\n      \"Unable to authenticate because the request was made with no session in context to transition.\"\n    );\n  }\n  context.session.set(\"user\", { [LINK_PARAM]: context.scope.authenticatedUser.id });\n}\n\nexport function legacyUnsetUser() {\n  const context = getActionContextFromLocalStorage();\n\n  if (!context.session) {\n    throw new NoSessionForAuthenticationError(\"Unable to unset users on session because the request was made with no session.\");\n  }\n  context.session.delete(\"user\");\n}\n\nexport async function legacySuccessfulAuthentication(params: AnyParams) {\n  const context = getActionContextFromLocalStorage();\n  const { api, scope } = context;\n\n  const user = (await api.internal.user.findMany({ filter: { email: { equals: params.email } } }))[0];\n  let result = false;\n  if (user && params.password && user.password?.hash) {\n    if (await Globals.platformModules.bcrypt().compare(params.password, user.password.hash)) {\n      scope.authenticatedUser = user;\n      result = true;\n    }\n  }\n  Globals.logger.info({ email: params.email, userId: user?.id, result }, \"login attempt\");\n\n  if (!result) {\n    throw new Error(\"Invalid email or password\");\n  }\n}\n\n/**\n * Internal helper functions and variables\n */\n\n/**\n * Get action context without `params` and `record` from async local storage.\n */\nfunction getActionContextFromLocalStorage() {\n  return assert(actionContextLocalStorage.getStore(), \"this effect function should only be called from within an action\");\n}\n\n/**\n * Similar to `getActionContextFromLocalStorage` but returns `undefined` if there is no action context. (i.e. possibly called from a route)\n */\nfunction maybeGetActionContextFromLocalStorage() {\n  return actionContextLocalStorage.getStore();\n}\n\nfunction getCurrentContext() {\n  return assert(Globals.requestContext.get(\"requestContext\"), \"no gadget context found on request\");\n}\n\nconst LINK_PARAM = \"_link\";\n\nfunction writableAttributes(model: ModelMetadata, record: GadgetRecord<RecordData>) {\n  const fieldsByApiIdentifier = Globals.platformModules.lodash().keyBy(Object.values(model.fields) as NotYetTyped[], \"apiIdentifier\");\n  return Globals.platformModules.lodash().pickBy(record, (v: any, k: any) => fieldsByApiIdentifier[k]?.internalWritable);\n}\n\nfunction changedAttributes(model: ModelMetadata, record: GadgetRecord<RecordData>) {\n  const changes = record.changes();\n  const attributes = Object.keys(changes).reduce((attrs, key) => {\n    attrs[key] = record[key];\n    return attrs;\n  }, {} as any);\n  return writableAttributes(model, attributes);\n}\n\nconst getModelByApiIdentifier = (apiIdentifier: string): ModelMetadata => {\n  const typename = modelListIndex[`api:${apiIdentifier}`];\n  if (!typename) {\n    throw new InternalError(`Model ${apiIdentifier} not found in available model metadata`, {\n      availableApiIdentifiers: Object.keys(modelListIndex),\n    });\n  }\n\n  return getModelByTypename(typename);\n};\n\nconst getModelByTypename = (typename: string): ModelMetadata => {\n  if (!typename) {\n    throw new InternalError(`No typename found on record, __typename must be set for accessing model metadata`);\n  }\n\n  const model = modelsMap[typename];\n  if (!model) {\n    throw new InternalError(`Model with typename ${typename} not found in available model metadata`, {\n      availableTypenames: Object.keys(modelsMap),\n    });\n  }\n\n  return model;\n};\n\nexport enum FieldType {\n  ID = \"ID\",\n  Number = \"Number\",\n  String = \"String\",\n  Enum = \"Enum\",\n  RichText = \"RichText\",\n  DateTime = \"DateTime\",\n  Email = \"Email\",\n  URL = \"URL\",\n  Money = \"Money\",\n  File = \"File\",\n  Color = \"Color\",\n  Password = \"Password\",\n  Computed = \"Computed\",\n  HasManyThrough = \"HasManyThrough\",\n  BelongsTo = \"BelongsTo\",\n  HasMany = \"HasMany\",\n  HasOne = \"HasOne\",\n  Boolean = \"Boolean\",\n  Model = \"Model\",\n  Object = \"Object\",\n  Array = \"Array\",\n  JSON = \"JSON\",\n  Code = \"Code\",\n  EncryptedString = \"EncryptedString\",\n  Vector = \"Vector\",\n  /**\n   * Any value at all.\n   * Prefer FieldType.JSON where possible, it's more descriptive.\n   */\n  Any = \"Any\",\n  Null = \"Null\",\n  RecordState = \"RecordState\",\n  RoleAssignments = \"RoleAssignments\",\n}\n\nconst shopifyModelKey = (modelName: string) => {\n  const modelKey = modelName.replaceAll(\" \", \"\");\n  return `DataModel-Shopify-${modelKey}`;\n};\n\nconst ShopifyShopKey = shopifyModelKey(\"Shop\");\n\nconst ShopifyBulkOperationGIDForId = (id: string) => `gid://shopify/BulkOperation/${id}`;\n"],
  "mappings": "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",
  "names": ["FieldType"]
}
